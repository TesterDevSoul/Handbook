# 文章名
## 本章要点
1. 要点一
1. 要点
1. 要点
1. 要点




## 计算器系统说明

计算器进行了功能增加，新增了**减法**功能对应的方法为`subtract()`，**字段拼接**功能对应的方法为`concatStr()`。

`subtract()`方法为带参的方法，可以传入**2个int类型的参数**。

当传入的参数其中一个 **>99** 或者 **<-99** 时，报错。错误类型为：`IllegalArgumentException`，对应的提示信息为：`Please enter an integer in the range!`

### 被测代码
```java
import org.slf4j.Logger;
import java.util.Arrays;
import java.util.UUID;
import java.util.stream.IntStream;
import static java.lang.invoke.MethodHandles.lookup;
import static org.slf4j.LoggerFactory.getLogger;


public class MySUT {
    //获得具有所需名称的记录器
    static final Logger logger = getLogger(lookup().lookupClass());
    //用例名
    String name;
    //唯一ID标识
    String id;

    public MySUT(String name) {
        this.name = name;
        logger.info("Open {} ", name);
    }
    public void initId(){
        id = UUID.randomUUID().toString();
        logger.info("Generate ID：{} ", id);
    }
    public void destroyId() {
        if (id == null) {
            throw new IllegalArgumentException(name + " 没有初始化对应ID");
        }
        logger.info("Release ID: {} ", id);
        id = null;
    }

    public void close() {
        logger.info("Close {} ", name);
    }

    //连续添加
    public int sum(int... numbers) {
        if(Arrays.stream(numbers).anyMatch(u -> u == 100) | Arrays.stream(numbers).anyMatch(u -> u == -100)){
            //输入100
            logger.warn("Enter an integer is 100！");
            throw new NumberFormatException("Enter an integer is 100！");
        }else if (Arrays.stream(numbers).anyMatch(u -> u > 99) |
                Arrays.stream(numbers).anyMatch(u -> u < -99)){
            // 请输入范围内的整数
            logger.warn("Please enter an integer in the range!");
            throw new IllegalArgumentException("Please enter an integer in the range!");
        }else {
            return IntStream.of(numbers).sum();
        }
    }

    //从100进行减法
    public int subtract(int... numbers) {
        if(Arrays.stream(numbers).anyMatch(u -> u > 99) | Arrays.stream(numbers).anyMatch(u -> u < -99)){
            logger.warn("Please enter an integer in the range!");
            throw new IllegalArgumentException("Please enter an integer in the range!");
        }else {
            return IntStream.of(numbers).reduce(100, (a, b) -> a-b);
        }
    }
    public int subtract(int x, int y) {
        if(x>99 | x<-99 | y>99 | y<-99){
            logger.warn("Please enter an integer in the range!");
            throw new IllegalArgumentException("Please enter an integer in the range!");
        }else {
            return x-y;
        }
    }
    //平均值 average
    public double average(int... numbers) {
        if(Arrays.stream(numbers).anyMatch(u -> u > 99) | Arrays.stream(numbers).anyMatch(u -> u < -99)){
            logger.warn("Please enter an integer in the range!");
            throw new IllegalArgumentException("Please enter an integer in the range!");
        }else {
            return IntStream.of(numbers).average().getAsDouble();
        }
    }
    //连续拼接
    public String concatStr(String... words) {
        return String.join(" ", words);
    }
}
```









## 实战一
### 测试准备

根据被测代码编写相关测试用例。

[减法测试用例](减法测试用例.xlsx)


![](https://cdn.jsdelivr.net/gh/TesterDevSoul/pic/manual/20230227110336.png)




### 多个int相减，正向

#### 步骤
1. 创建加法计算器对象。
2. 生成唯一ID。
3. log日志打印：`开始进行{}计算,加法`。
4. 业务逻辑调用，返回结果声明为result。
>8-2=6；<br>3-6=-3；<br>99-99=0；<br>99-(-99)=198；<br>-99-99=-198；<br>-99-(-99)=0。
5. log日志打印计算结果：`计算结果为{},result`。
6. 销毁ID操作。
7. 关闭计算器。
8. 计算的结果断言。

#### 要求
1. 在测试方法上添加说明：a-b=c。
2. 在测试类上添加说明：减法测试类。

#### 涉及知识点

|知识点|备注|
|:-:| --- |
|[@DisplayName注解](/archives/junit07)| 1. 带注释的**测试类**或**测试方法**声明自定义显示名称。<br>2. 可包含空格、特殊字符甚至表情符号😊。<br>|

#### 示例代码
```java
@DisplayName("减法测试类")
public class SubTest {
    static final Logger logger = getLogger(lookup().lookupClass());
    static MySUT mySUT;

    @BeforeAll
    public static void beforeAll(){
        //1. 创建加法计算器对象 -- new有参构造，传入参数值为：加法计算器
        mySUT = new MySUT("Sum Calculator");
    }
    @BeforeEach
    public void beforeEach(){
        //2. 生成唯一ID
        mySUT.initId();
        //3. log日志打印：开始进行{}计算,加法
        logger.info("Start adding...");
    }
    @AfterEach
    public void afterEach(){
        //6. 销毁ID操作
        mySUT.destroyId();
    }

    @AfterAll
    public static void afterAll(){
        //7. 关闭计算器
        mySUT.close();
    }

    //8，2；
    @DisplayName("8-2=6")
    @Test
    public void subOne(){
        //4. 业务逻辑调用，返回结果声明为result
        int result = mySUT.subtract(8, 2);
        //5. log日志打印计算结果：计算结果为{},result
        logger.info("Calculated as: {}", result);

        //8. 计算的结果断言 -- assertEquals()，断言失败msg：99+99计算错误
        /**
         * expected   期望值，10
         * actual     实际值，result
         * message    断言失败原因的解释说明，2+8计算错误
         */
        assertEquals(6, result, 8 + " - " + 2 + "计算错误");
    }

        // 3，6；
    @DisplayName("3-6=-3")
    @Test
    public void subTwo(){
        //4. 业务逻辑调用，返回结果声明为result
        int result = mySUT.subtract(3, 6);
        //5. log日志打印计算结果：计算结果为{},result
        logger.info("Calculated as: {}", result);

        //8. 计算的结果断言 -- assertEquals()，断言失败msg：99+99计算错误
        /**
         * expected   期望值，10
         * actual     实际值，result
         * message    断言失败原因的解释说明，2+8计算错误
         */
        assertEquals(-3, result, 3 + " - " + 6 + "计算错误");
    }
    //99，99； 99，-99； -99，99； -99，-99；
    @DisplayName("99-99=0")
    @Test
    public void subtractBoundaryOne(){
        //4. 业务逻辑调用，返回结果声明为result
        int result = mySUT.subtract(99, 99);
        //5. log日志打印计算结果：计算结果为{},result
        logger.info("Calculated as: {}", result);

        //8. 计算的结果断言 -- assertEquals()，断言失败msg：99+99计算错误
        /**
         * expected   期望值，10
         * actual     实际值，result
         * message    断言失败原因的解释说明，2+8计算错误
         */
        assertEquals(0, result, 99 + " - " + 99 + "计算错误");
    }

    @DisplayName("99-(-99)=0")
    @Test
    public void subtractBoundaryTwo(){
        //4. 业务逻辑调用，返回结果声明为result
        int result = mySUT.subtract(99, -99);
        //5. log日志打印计算结果：计算结果为{},result
        logger.info("Calculated as: {}", result);

        //8. 计算的结果断言 -- assertEquals()，断言失败msg：99+99计算错误
        /**
         * expected   期望值，10
         * actual     实际值，result
         * message    断言失败原因的解释说明，2+8计算错误
         */
        assertEquals(198, result, 99 + " - " + (-99) + "计算错误");
    }

    @DisplayName("-99-99=-198")
    @Test
    public void subtractBoundaryThree(){
        //4. 业务逻辑调用，返回结果声明为result
        int result = mySUT.subtract(-99, 99);
        //5. log日志打印计算结果：计算结果为{},result
        logger.info("Calculated as: {}", result);

        //8. 计算的结果断言 -- assertEquals()，断言失败msg：99+99计算错误
        /**
         * expected   期望值，10
         * actual     实际值，result
         * message    断言失败原因的解释说明，2+8计算错误
         */
        assertEquals(-198, result, -99 + " - " + 99 + "计算错误");
    }
    @DisplayName("-99-(-99)=0")
    @Test
    public void subtractBoundaryFour(){
        //4. 业务逻辑调用，返回结果声明为result
        int result = mySUT.subtract(-99, -99);
        //5. log日志打印计算结果：计算结果为{},result
        logger.info("Calculated as: {}", result);

        //8. 计算的结果断言 -- assertEquals()，断言失败msg：99+99计算错误
        /**
         * expected   期望值，10
         * actual     实际值，result
         * message    断言失败原因的解释说明，2+8计算错误
         */
        assertEquals(0, result, -99 + " - " + -99 + "计算错误");
    }
}
```


![](https://cdn.jsdelivr.net/gh/TesterDevSoul/pic/manual/20230227142916.png)



## 实战二

发现运行的测试方法不是按编写的方法名前后进行运行。

需求：
- 按照测试用例编写的顺序运行测试方法。



#### 涉及知识点

|知识点|备注|
|:-:| --- |
|[@Order注解](/archives/junit07)| 1. @Order注解修饰的方法不可直接运行。<br>2. @BeforeEach注解修饰的方法没有返回值。<br>3. @BeforeEach注解在每个@Test之**前**都运行一次。|









```java
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.slf4j.Logger;
import top.testeru.MySUT;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import static java.lang.invoke.MethodHandles.lookup;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.params.provider.Arguments.arguments;
import static org.slf4j.LoggerFactory.getLogger;


public class SubTest {

    static final Logger logger = getLogger(lookup().lookupClass());
    static MySUT mySUT;
    @BeforeAll
    public static void beforeAll(){
        //1. 创建加法计算器对象 -- new有参构造，传入参数值为：加法计算器
        mySUT = new MySUT("Sum Calculator");
    }
    @BeforeEach
    public void beforeEach(){
        //2. 生成唯一ID
        mySUT.initId();
        //3. log日志打印：开始进行{}计算,加法
        logger.info("Start adding...");
    }
    @AfterEach
    public void afterEach(){
        //6. 销毁ID操作
        mySUT.destroyId();
    }

    @AfterAll
    public static void afterAll(){
        //7. 关闭计算器
        mySUT.close();
    }

    //8，2； 3，6； 99，99； 99，-99； -99，99； -99，-99；
    //直接使用参数化校验
    @ParameterizedTest
    @MethodSource
    public void subOne(int a, int b, int c){
        //4. 业务逻辑调用，返回结果声明为result
        int result = mySUT.subtract(a, b);
        //5. log日志打印计算结果：计算结果为{},result
        logger.info("Calculated as: {}", result);

        //8. 计算的结果断言 -- assertEquals()，断言失败msg：99+99计算错误
        /**
         * expected   期望值，10
         * actual     实际值，result
         * message    断言失败原因的解释说明，2+8计算错误
         */
        assertEquals(c, result, a + " - " + b + "计算错误");
    }

    static Stream<Arguments> subOne() {
        return Stream.of(
                arguments(8, 2, 6),
                arguments(3, 6, -3),
                arguments(99, 99, 0),
                arguments(99, -99, 198),
                arguments(-99, 99, -198),
                arguments(-99, -99, 0)
        );
    }
}
```





 Tag
 DisplayName
 Order
