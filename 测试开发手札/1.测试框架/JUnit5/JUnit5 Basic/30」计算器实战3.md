# 计算器实战3
## 本章要点
1. 要点一
1. 要点
1. 要点
1. 要点




## 计算器优化


## 实战一
把减法测试用例中对应的所有业务操作一样的测试用例合并，使用参数化合并为同一个测试方法。

#### 要求：MethodSource

- 测试用例参数化。


#### 涉及知识点
|知识点|备注|
|:-:| --- |
|[@MethodSource注解](/archives/junit07)| 1.使用与方法名相同的参数源时，省略声明参数方法名。<br>2.使用与方法名不同的参数源时，需要在`@MethodSource`注解声明参数源名称。|

#### 示例代码


```java
public class SubTwoTest {

    static final Logger logger = getLogger(lookup().lookupClass());
    static MySUT mySUT;
    @BeforeAll
    public static void beforeAll(){
        //1. 创建加法计算器对象 -- new有参构造，传入参数值为：加法计算器
        mySUT = new MySUT("Sum Calculator");
    }
    @BeforeEach
    public void beforeEach(){
        //2. 生成唯一ID
        mySUT.initId();
        //3. log日志打印：开始进行{}计算,加法
        logger.info("Start adding...");
    }
    @AfterEach
    public void afterEach(){
        //6. 销毁ID操作
        mySUT.destroyId();
    }

    @AfterAll
    public static void afterAll(){
        //7. 关闭计算器
        mySUT.close();
    }

    //直接使用参数化校验
    @ParameterizedTest
    @MethodSource
    public void subOne(int a, int b, int c){
        //4. 业务逻辑调用，返回结果声明为result
        int result = mySUT.subtract(a, b);
        //5. log日志打印计算结果：计算结果为{},result
        logger.info("Calculated as: {}", result);
        //8. 计算的结果断言 -- assertEquals()，断言失败msg：99+99计算错误
        assertEquals(c, result, a + " - " + b + "计算错误");
    }

    static Stream<Arguments> subOne() {
        return Stream.of(
                arguments(8, 2, 6),
                arguments(3, 6, -3),
                arguments(99, 99, 0),
                arguments(99, -99, 198),
                arguments(-99, 99, -198),
                arguments(-99, -99, 0)
        );
    }
}
```


![](https://cdn.jsdelivr.net/gh/TesterDevSoul/pic/manual/20230228105102.png)

## 实战二

把在同一个类中的参数源提取到一个类中。简化类中的代码。



#### 要求：提取参数源到外部类

- 把参数源方法提取到外部类中。


#### 涉及知识点

|知识点|备注|
|:-:| --- |
|[@MethodSource注解](/archives/junit07)| 1.参数源不在同一类中，声明引用格式为：**包名.类名#方法名**。<br>2.参数源必须是`public`修饰。|


#### 示例代码


```java
package top.testeru.support;

public class MethodArguments {
    public static Stream<Arguments> subOne() {
        return Stream.of(
                arguments(8, 2, 6),
                arguments(3, 6, -3),
                arguments(99, 99, 0),
                arguments(99, -99, 198),
                arguments(-99, 99, -198),
                arguments(-99, -99, 0)
        );
    }
}
```


```java
public class SubThreeTest {

    static final Logger logger = getLogger(lookup().lookupClass());
    static MySUT mySUT;

    @BeforeAll
    public static void beforeAll(){
        //1. 创建加法计算器对象 -- new有参构造，传入参数值为：加法计算器
        mySUT = new MySUT("Sum Calculator");
    }
    @BeforeEach
    public void beforeEach(){
        //2. 生成唯一ID
        mySUT.initId();
        //3. log日志打印：开始进行{}计算,加法
        logger.info("Start adding...");
    }
    @AfterEach
    public void afterEach(){
        //6. 销毁ID操作
        mySUT.destroyId();
    }

    @AfterAll
    public static void afterAll(){
        //7. 关闭计算器
        mySUT.close();
    }

    //直接使用参数化校验
    @ParameterizedTest(name = "{0} + {1} = {2}")
    @MethodSource("top.testeru.support.MethodArguments#subOne")
    public void subOne(int a, int b, int c){
        //4. 业务逻辑调用，返回结果声明为result
        int result = mySUT.subtract(a, b);
        //5. log日志打印计算结果：计算结果为{},result
        logger.info("Calculated as: {}", result);
        //8. 计算的结果断言 -- assertEquals()，断言失败msg：99+99计算错误
        assertEquals(c, result, a + " - " + b + "计算错误");
    }
}
```


## 实战三

把参数源对应的值提取到yaml文件中，与代码再一次的解耦合。后求只需要提供对应的yaml文件给业务测试人员即可。对应代码无需改动。



#### 要求：YAML

- 把参数源内的值提取到yaml文件。


#### 涉及知识点

|知识点|备注|
|:-:| --- |
|[@MethodSource注解](/archives/junit07)| 1.参数源不在同一类中，声明引用格式为：**包名.类名#方法名**。<br>2.参数源必须是`public`修饰。|


#### 示例代码
##### 1. 添加对应依赖

```xml
<!--        yaml文件解析-->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>${jackson.version}</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-yaml</artifactId>
    <version>${jackson.version}</version>
</dependency>

```

##### 2. 编写yaml文件
```yml
#HashMap<String,List<HashMap<String, String>>>
datas:
    #List<HashMap<String, String>>
    - a: 8
        b: 2
        result: 6
        message: 有效2个整数【8,2】
        #HashMap<String, String>
    - a: 3
        b: 6
        result: -3
        message: 有效边界值相加【3,6】
    - a: 99
        b: 99
        result: 0
        message: 有效边界值相加【99,99】
    - a: 99
        b: -99
        result: 198
        message: 有效边界值相加【98,-99】
    - a: -99
        b: 99
        result: -198
        message: 有效边界值相加【-99,99】
    - a: -99
        b: -99
        result: 0
        message: 有效边界值相加【-99,-99】
```

##### 3. YAML文件基本数据类型解析
- Data：

```java
public class Data {
    private int a;
    private int b;
    private int result;
    private String message;

    //get、set、toString
}
```

- Num:

```java
public class Num {
    private List<Data> datas;

    //get、set、toString
}
```

- 解析代码：


```java
@Test
public void sub(){
    ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
    HashMap<String,List<HashMap<String, String>>> data;
    //食品加工厂中 加工牛奶的还是加工茶叶的 还是加工瓜子的
    TypeReference<HashMap<String,List<HashMap<String, String>>>> typeReference =
            new TypeReference<>(){};
    try {
        // readValue  相当于加工出来最终的结果 是茶叶还是纯奶 还是酸奶
        data = mapper.readValue(new File("src/test/resources/yaml/sub.yml"), typeReference);
        System.out.println(data);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
```

##### 4. YAML文件实体类解析

```java
@Test
public void subObj(){
    ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
    Num num;
    //食品加工厂中 加工牛奶的还是加工茶叶的 还是加工瓜子的
    TypeReference<Num> typeReference =
            new TypeReference<>(){};
    try {
        // readValue  相当于加工出来最终的结果 是茶叶还是纯奶 还是酸奶
        num = mapper.readValue(new File("src/test/resources/yaml/sub.yml"), typeReference);
        System.out.println(num);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
```

##### 5. 参数源替换
```java
public static Stream<Data> subData() {
    ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
    Num num;
    //食品加工厂中 加工牛奶的还是加工茶叶的 还是加工瓜子的
    TypeReference<Num> typeReference =
            new TypeReference<>(){};
    try {
        // readValue  相当于加工出来最终的结果 是茶叶还是纯奶 还是酸奶
        num = mapper.readValue(new File("src/test/resources/yaml/sub.yml"), typeReference);
        System.out.println(num);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
    return num.getDatas().stream();
}
```
